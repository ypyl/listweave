<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ListWeave</title>
    <link rel="stylesheet" href="src/styles.css" />
  </head>
  <body>
    <div id="root"></div>
    <script src="lw-elm.js"></script>
    <script>
      var app = Elm.Main.init({ node: document.getElementById("root") });

      function getCaretCoordinates(textarea, position) {
        // Create a mirror div
        const div = document.createElement("div");
        const style = getComputedStyle(textarea);
        for (const prop of style) {
          div.style[prop] = style[prop];
        }

        div.style.position = "absolute";
        // div.style.visibility = "hidden";
        div.style.whiteSpace = "pre-wrap";
        div.style.wordWrap = "break-word";
        div.style.overflow = "hidden";
        div.style.width = textarea.offsetWidth + "px";

        // Mirror scroll
        div.scrollTop = textarea.scrollTop;
        div.scrollLeft = textarea.scrollLeft;

        // Insert text up to caret, ensuring we don't cut words in half
        const fullText = textarea.value;
        let text = fullText.substring(0, position);

        // If we cut in the middle of a word, include the rest of the word
        if (position < fullText.length && /\w/.test(fullText[position])) {
          // Find the next non-word character (word boundary)
          const rest = fullText.slice(position);
          const nextBoundary = rest.search(/[^\w]/);
          if (nextBoundary !== -1) {
            text = fullText.substring(0, position + nextBoundary);
          } else {
            text = fullText;
          }
        }
        div.textContent = text;

        // Insert marker span
        const span = document.createElement("div");
        span.textContent = textarea.value.substring(position) || "."; // avoid empty
        div.appendChild(span);

        document.body.appendChild(div);

        const rect = span.getBoundingClientRect();
        const divRect = div.getBoundingClientRect();
        const taRect = textarea.getBoundingClientRect();

        document.body.removeChild(div);

        return {
          top: rect.top - divRect.top + taRect.top + textarea.scrollTop,
          left: taRect.left,
          width: textarea.offsetWidth,
        };
      }

      app.ports.setCaret.subscribe(function (data) {
        const id = data.id;
        const pos = data.pos;
        const input = document.getElementById("input-id-" + id);
        if (input) {
          input.focus();
          input.setSelectionRange(pos, pos);
          autoResize.call(input);
        }
      });

      app.ports.resizeTextarea.subscribe(function (id) {
        const input = document.getElementById("input-id-" + id);
        if (input) {
          autoResize.call(input);
        }
      });

      app.ports.requestCursorPosition.subscribe(function (id) {
        // Find the textarea element by its value
        const textarea = document.getElementById("input-id-" + id);
        if (!textarea) {
          return;
        }
        const cursorPos = textarea.selectionStart;
        const coords = getCaretCoordinates(textarea, cursorPos);

        if (app.ports && app.ports.receiveCursorPosition) {
          app.ports.receiveCursorPosition.send({
            top: Math.ceil(coords.top),
            left: Math.ceil(coords.left),
            width: Math.ceil(coords.width),
          });
        }
      });

      app.ports.getSearchInputPosition.subscribe(function () {
        const searchInput = document.getElementById("search-input");
        if (!searchInput) {
          return;
        }

        const rect = searchInput.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

        if (app.ports && app.ports.receiveCursorPosition) {
          app.ports.receiveCursorPosition.send({
            top: Math.ceil(rect.bottom + scrollTop + 2),
            left: Math.ceil(rect.left + scrollLeft),
            width: Math.ceil(rect.width),
          });
        }
      });

      app.ports.setSearchInputCursor.subscribe(function (position) {
        const searchInput = document.getElementById("search-input");
        if (searchInput) {
          searchInput.focus();
          searchInput.setSelectionRange(position, position);
        }
      });

      app.ports.getCurrentCursorPosition.subscribe(function (itemId) {
        const textarea = document.getElementById("input-id-" + itemId);
        if (textarea && app.ports.receiveCurrentCursorPosition) {
          const cursorPos = textarea.selectionStart;
          app.ports.receiveCurrentCursorPosition.send({
            itemId: itemId,
            tag: "", // Will be handled by Elm
            cursorPos: cursorPos,
          });
        }
      });

      app.ports.getPosition.subscribe(function (data) {
        // data: { id: number, clientX: number, clientY: number }
        const viewItemId = data.id;
        const clientX = data.clientX;
        const clientY = data.clientY;

        const viewItem = document.getElementById("view-item-" + viewItemId);
        if (!viewItem) {
          return;
        }

        const contentDiv = viewItem.querySelector(".content-click-area");
        if (!contentDiv) {
          return;
        }

        const clickRange = document.caretRangeFromPoint
          ? document.caretRangeFromPoint(clientX, clientY)
          : document.caretPositionFromPoint?.(clientX, clientY);

        if (!clickRange || !contentDiv.contains(clickRange.startContainer)) {
          return;
        }

        const totalRange = document.createRange();
        totalRange.selectNodeContents(contentDiv);
        totalRange.setEnd(clickRange.startContainer, clickRange.startOffset);
        const offset = totalRange.toString().length;

        if (app.ports.clickedAt) {
          app.ports.clickedAt.send({ id: viewItemId, pos: offset });
        }
      });

      function autoResize() {
        const ta = this;

        // Ensure wrapping behaviour is consistent so scrollHeight reflects wrapped lines
        ta.style.whiteSpace = "pre-wrap";
        ta.style.wordWrap = "break-word";
        ta.style.overflowWrap = "anywhere";
        ta.style.overflow = "hidden";

        // Reset height so scrollHeight can shrink when content is removed
        ta.style.height = "auto";

        // Primary approach: use scrollHeight which accounts for wrapped lines
        let newHeight = ta.scrollHeight;

        // Fallback: if for some reason scrollHeight is unavailable or 0, measure with a mirror div
        if (!newHeight || newHeight === 0) {
          const mirror = document.createElement("div");
          const style = getComputedStyle(ta);
          for (const prop of style) {
            mirror.style[prop] = style[prop];
          }
          mirror.style.position = "absolute";
          mirror.style.visibility = "hidden";
          mirror.style.whiteSpace = "pre-wrap";
          mirror.style.wordWrap = "break-word";
          mirror.style.overflowWrap = "anywhere";
          mirror.style.width = ta.offsetWidth + "px";
          // Use textContent to match rendering and avoid injection
          mirror.textContent = ta.value || ".";
          document.body.appendChild(mirror);
          newHeight = mirror.getBoundingClientRect().height;
          document.body.removeChild(mirror);
        }

        // Add a tiny buffer to avoid scrollbars appearing
        const style = getComputedStyle(ta);
        const fontSize = parseFloat(style.fontSize) || 14;
        const minHeight = fontSize * 1.8;
        ta.style.height = Math.max(newHeight, minHeight) + "px";
      }

      window.addEventListener(
        "resize",
        () => {
          const textareas = document.querySelectorAll("textarea");
          textareas.forEach((textarea) => {
            autoResize.call(textarea);
          });
        },
        false
      );

      app.ports.downloadJson.subscribe(function (data) {
        const blob = new Blob([data.content], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = data.filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 0);
      });

      app.ports.readFile.subscribe(function () {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json";
        input.onchange = function (e) {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = function (event) {
            try {
              const json = JSON.parse(event.target.result);
              app.ports.receiveFile.send(json);
            } catch (err) {
              console.error("Failed to parse JSON file", err);
              // Optionally send an error message back to Elm
            }
          };
          reader.readAsText(file);
        };
        input.click();
      });
    </script>
  </body>
</html>
